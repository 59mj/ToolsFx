package me.leon

import java.math.BigInteger
import me.leon.ext.readFromNet
import org.junit.Test

/**
 * p q 两个素数 dp dq 两个指数
 *
 * dp = e^-1 mod (p-1) dq = e^-1 mod (q-1)
 *
 * n = p * q phi = (p - 1) * (q - 1) e = 65537 (一般选择65537) d = e^-1 mod phi
 *
 * c = m^e mod n m = c^d mod n
 *
 * 公钥：(e, n) 私钥：(d, n)
 */
class Rsa {

    /**
     * 已知 n e phiN 三个数，求 d +密文c 求解出明文m
     *
     * n较小
     */
    @Test
    fun rsa1() {
        val c = "421345306292040663864066688931456845278496274597031632020995583473619804626233684"
        val n = "631371953793368771804570727896887140714495090919073481680274581226742748040342637"
        val e = "65537"
        val phiN =
            "631371953793368771804570727896887140714061729769155038068711341335911329840163136"
        solveNEPhi(n, e, phiN, c).also { println(it) }
    }

    private fun solveNEPhi(n: String, e: String, phiN: String, c: String): String {
        val d = e.toBigInteger().modInverse(phiN.toBigInteger())
        return c.toBigInteger().modPow(d, n.toBigInteger()).toByteArray().decodeToString()
    }

    private fun solve(n: String, e: String, c: String): String {
        val (p, q) = getPrime(n)
        val phiN = (p.toBigInteger() - BigInteger.ONE) * (q.toBigInteger() - BigInteger.ONE)
        val d = e.toBigInteger().modInverse(phiN)
        return c.toBigInteger().modPow(d, n.toBigInteger()).toByteArray().decodeToString()
    }

    /** 已知 p q e求d 已知 p q ==> n = pq , phiN = (p-1)(q-1) */
    @Test
    fun rsa2() {
        val p = 473398607161.toBigInteger()
        val q = 4511491.toBigInteger()
        val e = 17.toBigInteger()
        val phiN = (p.minus(BigInteger.ONE)) * (q - BigInteger.ONE)
        val d = e.modInverse(phiN)
        println(d)
    }

    /** 已知 p q e c求 m 已知 p q ==> n = pq , phiN = (p-1)(q-1) */
    @Test
    fun rsa3() {

        val p =
            ("9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427" +
                    "050370107570733633350911691280297777160200625281665378483").toBigInteger()
        val q =
            ("1187484383798029703209240584865365685276091015454338090765004019070428335890920857825106304773244" +
                    "3992230647903887510065547947313543299303261986053486569407").toBigInteger()
        val e = "65537".toBigInteger()
        val c =
            ("832082989951746041747735902982036393605400248712561268928896613457424033149298619391004926666056" +
                    "47316646576486526217457006376842280869728581726746401583705899941768214138742259689334840" +
                    "735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392" +
                    "737747832762751690104423869019034").toBigInteger()
        val n = p * q
        val phiN = (p - BigInteger.ONE) * (q - BigInteger.ONE)
        val d = e.modInverse(phiN)
        c.modPow(d, n).also { println(it) }.toByteArray().toString().also { println(it) }
    }


    @Test
    fun factor() {
        val bigDigit =
            "1346863473634347390771796960343437621220633518755545874225794040661818948117783599221788567624315" +
                    "5145465521141546915941147336786447889325606555333350540003"
        getPrime(bigDigit).also { println(it) }
        val bigDigit2 =
            "2482540078515262411777215266989018029858327661762216096122588773716205800604331015383280303052" +
                    "199186976436198142009306796121098855338013353484450237516704784370730555447242806847332" +
                    "980515991676603036451831461614974853586336814921296688024020657977899055504895476451187" +
                    "87266601929429724133167768465309665906113"
        getPrime(bigDigit2).also { println(it) }
        getPrime("183469842288888698417653802680141427113").also { println(it) }
        val bigDigit3 =
            "1141976890333971618926153237155970525208639827587600850504737512307472709358968061186974826335155" +
                    "4093957968142343831331654606932684767042958427409579115435445187908134556329979271179879129" +
                    "2956674764938867872309485203713507158089884960836947175442983432603698169802283944988567510" +
                    "9619194201154589898424028187450979188069009284053659777167477261729940771077142696476434756" +
                    "600889701275302276327083264777557131716259404433809587040455066545789922339494264087685069" +
                    "28486718265947502369103630279494597681246462305557663234176934418614365600722888121379448849" +
                    "54974348317322412816157152702695143094487806945533233359294549423"
        getPrime(bigDigit3).also { println(it) }
    }

    @Test
    fun rsa_nec() {
        val n =
            "114197689033397161892615323715597052520863982758760085050473751230747270935896806118697482633515540" +
                    "9395796814234383133165460693268476704295842740957911543544518790813455632997927117987912929" +
                    "5667476493886787230948520371350715808988496083694717544298343260369816980228394498856751096" +
                    "1919420115458989842402818745097918806900928405365977716747726172994077107714269647643475660" +
                    "08897012753022763270832647775571317162594044338095870404550665457899223394942640876850692848" +
                    "67182659475023691036302794945976812464623055576632341769344186143656007228881213794488495497" +
                    "4348317322412816157152702695143094487806945533233359294549423"
        val e = "65537"
        val c =
            "5750617109503811182067350738063981163707065870767757652534831310783169080732021438023861282723743236" +
                    "162390831347473182544367068067817445019033336047729619279667476489543159622693212971214953980" +
                    "579386171450179994827221976610656987078368245050238563064038923079442032455634119613024993476" +
                    "044170240646789990036379331851779228841033622036393492982633398085081858616925969671470813825" +
                    "662466276688987742330291986945005655113618673756683678758059856607051371096651078607992776240" +
                    "502106668669585029480623300373098731489630111924050128119455401535920903456682659644772044653" +
                    "27474208098404082920129178960510763496025906621820"
        solve(n, e, c).also { println(it) }
    }

    private fun getPrime(digit: String): List<String> {
        "http://www.factordb.com/index.php?query=$digit".readFromNet().also {
            "index\\.php\\?id=\\d+".toRegex().findAll(it).toList().map { it.value }.also {
                if (it.size >= 3) {
                    val map = it.filterIndexed { i, _ -> i != 0 }.map { getPrime2(it) }
                    println("$digit = \n\t ${map.joinToString("\n\t*")}")
                    return map
                } else {
                    println("无法分解")
                    return listOf(digit)
                }
            }
        }
    }

    private fun getPrime2(path: String) =
        "http://www.factordb.com/$path".readFromNet().run {
            "value=\"(\\d+)\"".toRegex().find(this)!!.groupValues[1]
        }
}
